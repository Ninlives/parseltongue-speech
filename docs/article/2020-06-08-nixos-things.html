<html lang="en"><head><meta charset="utf-8"><meta content="ie=edge" http-equiv="x-ua-compatible"><meta content="width=device-width, initial-scale=1" name="viewport"><title>Parseltongue Speech - 关于Nix的一些事
</title><style type="text/css">
*
{
  -webkit-box-sizing : border-box;
  -moz-box-sizing    : border-box;
  -ms-box-sizing     : border-box;
  -o-box-sizing      : border-box;
  box-sizing         : border-box;
  text-rendering     : geometricPrecision;
}

html
{
  font-size        : 100%;
  font-family      : "Menlo","Monaco","Lucida Console","Liberation Mono","DejaVu Sans Mono","Bitstream Vera Sans Mono","Courier New", monospace,serif;
  min-height       : 100%;
  background-color : #282828;
  color            : #ebdbb2;
}

body
{
  font-size   : 1rem;
  line-height : 1.5rem;
  margin      : 0px 0px 0px 0px;
  word-wrap   : break-word;
  min-height  : 100%;
}

h1,
h2,
h3,
h4,
h5,
h6,
blockquote,
code,
footer,
header,
li,
ol,
p,
section,
ul
{
  float   : none;
  margin  : 0px 0px 0px 0px;
  padding : 0px 0px 0px 0px;
}

header > h1
{
  position  : relative;
  display   : inline-block;
  display   : table-cell;
  color     : #458588;
  font-size : 1.19999rem;
  padding   : 1.5rem 0rem 2rem 0rem;
  overflow  : hidden;
}

header > h1::after
{
  content  : "========================================================================================================================";
  position : absolute;
  bottom   : 0.75rem;
  left     : 0rem;
}

header > h1::before
{
  content : "";
}

h1 a,
h2 a,
h3 a,
h4 a,
h5 a,
h6 a,
a
{
  color           : #fb4934;
  text-decoration : none;
}

h1,
h2,
h3,
h4,
h5,
h6
{
  line-height   : 1.3em;
  font-size     : 1.1rem;
  color         : #98971a;
  position      : relative;
  margin-bottom : 0.75rem;
}

h1::before
{
  display : inline;
  content : "# ";
}

h2::before
{
  display : inline;
  content : "## ";
}

h3::before
{
  display : inline;
  content : "### ";
}

h4::before
{
  display : inline;
  content : "#### ";
}

h5::before
{
  display : inline;
  content : "##### ";
}

h6::before
{
  display : inline;
  content : "###### ";
}

li
{
  position      : relative;
  display       : block;
  padding-left  : 20px;
  margin-bottom : 0.2rem;
}

li::after
{
  position : absolute;
  top      : 0px;
  left     : 0px;
}

ul > li::after
{
  content : "-";
}

ol
{
  counter-reset : a;
}

ol > li::after
{
  content           : counter(a) ".";
  counter-increment : a;
}


:not(li) > p,
:not(li) > ol,
:not(li) > ul
{
  margin-bottom : 1rem;
}

blockquote
{
  position      : relative;
  padding-left  : 1rem;
  margin-top    : 0.5rem;
  margin-bottom : 1rem;
  overflow      : hidden;
  color         : #a89984;
}

blockquote::after
{
  content     : ">\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A";
  white-space : pre;
  position    : absolute;
  top         : 0px;
  left        : 0px;
}

blockquote > p
{
  margin-bottom : 0rem;
}

blockquote,
code
{
  font-size : 1rem;
}

em
{
  font-style : italic;
}

em::after,
em::before
{
  content : "/";
  display : inline;
}

strong
{
  color : #d79921;
}

strong::after,
strong::before
{
  content : "*";
  display : inline;
}


:not(pre) > code
{
  color       : #689d6a;
  font-family : "Menlo","Monaco","Lucida Console","Liberation Mono","DejaVu Sans Mono","Bitstream Vera Sans Mono","Courier New", monospace,serif;
}

:not(pre) > code::after,
:not(pre) > code::before
{
  content : "`";
  display : inline;
}

pre
{
  background-color : #1d2021;
  color            : #98971a;
}

footer
{
  color    : #504945;
  bottom   : 0rem;
  position : relative;
}

.container
{
  max-width   : 60%;
  min-height  : 100%;
  margin      : 0px auto 0px auto;
  margin-left : 20%;
  padding     : 0px 1rem 0px 1rem;
}

.inner
{
  min-height : 95%;
}


/* Generated with Clay, http://fvisser.nl/clay */</style></head><body><div class="container"><div class="inner"><a href="index.html">Home</a> - <a href="posts.html">Posts</a><header><h1>关于Nix的一些事
</h1></header><article><ul>
<li><a href="#前言">前言</a></li>
<li><a href="#纯函数式包管理">纯函数式包管理</a></li>
<li><a href="#可重现构建">可重现构建</a>
<ul>
<li><a href="#fixed-output-derivation-without-dependency">Fixed-Output Derivation without Dependency</a></li>
<li><a href="#normal-derivation-with-some-dependency">Normal Derivation with Some Dependency</a></li>
</ul></li>
<li><a href="#总结">总结</a></li>
</ul><p>本来是想简单介绍一下NixOS以及在Macbook Pro 2016上安装NixOS的一些建议, 结果拖到了现在电脑都换成戴尔了… 想起什么写什么吧.</p>
<h1 id="前言">前言</h1>
<p>Nix是Linux上的又一个包管理器. 在<a href="https://nixos.org">官网</a>的介绍中宣称Nix是一个“纯函数式包管理器(purely functional package manager)”. 这里的“纯函数式”指什么呢? 我个人对它的理解是包含了两层意思:</p>
<ol type="1">
<li>Nix使用了一种纯函数式的语言定义和配置package.</li>
<li>Nix利用了各种方法使package的编译构建以及运行满足“纯函数式”的要求.</li>
</ol>
<p>这两条在接下去的几个小节中解释. 由于本文本来是想写成安利向的,所以先罗列一下我个人心目中Nix区别于其他包管理器的特色:</p>
<ul>
<li><strong>独立的依赖管理</strong>: 不同的package可以各自依赖同一个package的不同版本而不发生冲突, 即避免了“Dependency Hell”的问题. 同时, 安装或升级一个package也不会出现覆盖已有package的依赖的情况.
<ul>
<li>也就是不会出现类似 <em>“我升级了libreoffice然后gimp挂掉了”</em> 这种事情.</li>
</ul></li>
<li><strong>可精确重现的运行环境和构建过程</strong>: Nix可以根据一份<code>.nix</code>文件执行一个package的构建, 或者创建一个运行环境, 而这两件事情可以在任意相同架构的系统上精确地重现, 不论系统原本的环境是怎么样的. (没有使用容器, 但也可以和容器结合实现更好的复现)
<ul>
<li>换句话说, <em>“但在我的机器上是没问题的啊!”</em> 这种对白就会少很多.</li>
</ul></li>
<li><strong>“一次性”安装</strong>: 或者叫“用完即走”, 当你临时需要使用一个程序, 或者只是想试一试某个命令的时候, 可以使用<code>nix run &lt;package&gt;</code>或者<code>nix-shell -p &lt;package&gt;</code>创建一个可以使用<code>&lt;package&gt;</code>的shell, 执行结束后<code>exit</code>退出即可, 而这个package并没有实际被安装到系统中.
<ul>
<li>如果你和我一样不希望系统在一次次<code>apt install</code>中变得乱七八糟的, 手动清理又担心删不干净, 你应该会喜欢这个功能的 :).</li>
<li>事实上Nix允许声明式的定义系统的状态, 然后将系统设置为所定义的状态 – 该有的就有, 不该有的就没有, 很干净.</li>
</ul></li>
<li><strong>原子性、可回滚的包管理操作</strong>: 安装或升级一个package的操作是原子性的, 即要么package安装成功然后系统被更新, 要么系统环境保持不变, 不存在装到一半然后失败但是很多依赖已经安装上来的尴尬局面. 同时所有的包管理操作都是可以回滚的(只要旧版本没有被删除. Nix中任何安装升级操作都不会覆盖或删除已有的package, 但提供了垃圾回收指令手动删除). 而在NixOS中, 对系统的更新也是可以回滚的. 比如折腾N卡驱动把X Server搞炸了, 重启进入上一个可以正常运行的版本就好.
<ul>
<li>总之用上NixOS之后折腾系统的时候越来越浪了XD.</li>
</ul></li>
</ul>
<h1 id="纯函数式包管理">纯函数式包管理</h1>
<p>在我个人 <em>片面</em> 的认知中, <strong>纯函数式编程</strong>包含了以下特征:</p>
<ul>
<li>变量的值是不可变的.</li>
<li>函数的执行是没有副作用的.</li>
<li>使用相同的参数调用同一个函数总是返回相同的结果, 即函数的运算结果仅和输入有关.</li>
</ul>
<p>纯函数式编程的优缺点在此就不再赘述, 而Nix显然认为纯函数式的思想在包管理这个领域依然可以带来诸多好处. 于是, 在Nix的模型中, package被抽象为一种像<code>int</code>, <code>string</code>, <code>list</code>, <code>set</code>等一样可赋值给变量、可参与计算的数据类型, Nix将这个类型命名为<code>derivation</code>. 一个<code>derivation</code>是调用一个构造器构造得到的, 而一个package的构建被抽象为对一个<code>derivation</code>求值的过程.</p>
<p>当一个package成为纯函数式编程中的一个值, 就 <em>应当</em> 有以下性质:</p>
<ul>
<li>一个package在被构建出来后应当不再可变, 即文件只读, 不可被覆盖/删除/修改.</li>
<li>一个package的构建过程不会影响系统的状态.</li>
<li>使用相同参数调用得到的<code>derivation</code>所构建的package总是相同的, 且package的构建结果仅和这里的参数有关, 不受系统状态和其他无关的<code>derivation</code>的影响.</li>
</ul>
<p>一旦上述性质成立, 那么自然地, 我们就会得到:</p>
<ul>
<li><strong>独立的依赖管理</strong>: 因为<code>derivation</code>的求值不受其他无关<code>derivation</code>影响. (当然, 上述性质只能推导出 <em>构建时</em> 的独立依赖管理, 不过Nix项目也做了很多工作来实现独立的 <em>运行时</em> 依赖)</li>
<li><strong>原子性、可回滚的包管理操作</strong>: 由于对<code>derivation</code>的求值没有副作用, package的构建自然也不应当对系统状态产生影响. 而又因为已求得的值是不可变的, 只要对之前求得的值的引用还在, 随时可以用旧值替换新值作为输入构造新的系统状态(实际上就是一个package set), 而根据纯函数的性质, 这个“新”的系统状态和之前第一次使用旧值构造的应该是一致的.</li>
</ul>
<p>而<strong>可精确重现的运行环境和构建过程</strong>, 则是用于确保对<code>derivation</code>的求值满足纯函数式的定义. 在下一小节会讲解.</p>
<p>在具体的实现上, 每个package被构建出来后都会存放在<code>/nix/store</code>下的一个只读路径, 路径的格式为<code>/nix/store/&lt;hash&gt;-&lt;name&gt;</code>. 其中<code>&lt;name&gt;</code>对应<code>derivation</code>的名称, 而<code>&lt;hash&gt;</code>则是用于构造<code>derivation</code>所使用的所有参数和依赖的Hash值(除了“fixed-output derivation”, 这里暂时不讨论). 也就是说, 一旦构造<code>derivation</code>的参数(其中包含了package的依赖树和构建脚本)发生任何变化, 其路径就会不同. 看起来有一点像Gentoo中的Slot, 但是这里的“版本号”是根据package的依赖树和构建脚本唯一确定的.</p>
<p>而“安装”这一过程, 在Nix中只是建立了一些指向<code>/nix/store</code>中的某些目标路径的符号链接, 这也就是Nix包管理操作具有原子性的原因 – package的构建过程只会在<code>/nix/store</code>下产生新的路径, 对系统其他部分不会有任何影响, 也不会修改<code>/nix/store</code>下已有的路径. 在构建成功后, 更新过程仅是切换符号链接的目标而已. 若是构建失败, 则不会在<code>/nix/store</code>之外产生任何变化. 而回滚操作就是简单地将符号链接指向之前的路径.</p>
<p>而“一次性”的安装就更简单了 – package的路径只是被临时加入了<code>PATH</code>中, 一旦shell进程退出, 对系统来说这个package就不存在了.</p>
<p>在我的理解中, <code>/nix/store</code>中的文件就类似nix-lang程序运算中产生的<code>derivation</code>值的持久化缓存, 而这些缓存“恰好”可以作为包管理的“材料”, 而Nix则为此提供了一套工具链.</p>
<h1 id="可重现构建">可重现构建</h1>
<p>先简单介绍一下Nix的核心部分: Nix语言. 这是Nix使用的配置语言, 由于名字也叫Nix, 为了避免混淆下面都用nix-lang指代这个语言.</p>
<p>nix-lang是一种“伪纯函数式”编程语言 – 为了实用性nix-lang默认允许在运行中读取环境变量以及任意位置的文件, 但也提供了“pure eval mode”关闭这两项能力, 同时nix-lang在对<code>derivation</code>的求值过程中将不可避免地涉及网络IO, 但在nix-lang中可以通过 <em>Fixed Output</em> 的约束将其影响降到最低. 除此之外的部分均符合纯函数式语言的定义(当然, 纯函数式编程的定义是有争议的, 这里仅讨论上一小节提到的三个特征).</p>
<p>虽然是设计为用于包管理器的DSL, 但nix-lang本身是图灵完全的, 提供了常见的基本数据类型、Lamba表达式、惰性求值等特性.</p>
<p><a href="https://github.com/NixOS/nixpkgs">nixpkgs</a>是官方维护的一份巨大的nix-lang library, 可以类比为Arch Linux的<a href="https://www.archlinux.org/packages">Package Repository</a>.</p>
<p>如上一小节所说, nix-lang中提供了名为<code>derivation</code>的数据类型来表示一个package, 并提供了若干内置的构造函数. 在这里我将<code>derivation</code>分成三类:</p>
<ol type="1">
<li><strong>Fetcher</strong>, 即这类<code>derivation</code>的求值过程就是单纯的从指定的URL或git/mercurial仓库下载文件. 由于涉及到网络IO, 这类<code>derivation</code>的求值显然是非纯函数式的, 任何依赖于它的计算过程也不能被认为是纯函数式的, 因此每次执行都需要重新计算(失去了引用透明性带来的好处, 无法使用cache), 会带来大量的开销(每次计算时都要重新下载所有文件, 但可设置文件到期时间), 好处是每次计算时这个<code>derivation</code>的值都是up-to-date的. 在pure eval mode中这类<code>derivation</code>无法创建.</li>
<li><strong>Fixed Output</strong>, 这类<code>derivation</code>的值已经确定, 换句话说其所构建出来的package文件的内容是已知的. 这类<code>derivation</code>的求值(构建)过程也可以使用网络IO, 但在nix-lang中将其视为是纯函数的. 在第一次对其求值之后, nix-lang验证结果的Hash值, 如果和参数中指定的Hash值相同, 则将结果缓存, 否则将报错.
<ul>
<li>也就是说Nix不确保这是一个纯函数, 但当它不符合纯函数的性质(相同输入得到不同的输出)的时候, Nix会发现并打断计算过程.</li>
</ul></li>
<li>普通的<code>derivation</code>, 虽然其输出值无法确定, 但其求值过程无法使用任何网络IO以及(当开启沙盒功能)除参数以外的其他值和文件, Nix假定这一过程是可重现的、求值仅和参数有关.
<ul>
<li>嗯没错这是一个假设, Nix的整个模型实际上是建立在这个假设之上的, 但由于Nix对构建环境的严格限制, 大部分情况下可以认为这个假设是成立的.</li>
</ul></li>
</ol>
<p>后两种<code>derivation</code>都是使用<code>builtins.derivation</code>这个函数构造的, 调用该函数的时候至少需要提供<code>name</code>, <code>builder</code>, <code>system</code>三个参数:</p>
<ul>
<li><strong>name</strong>: 指定<code>derivation</code>的名字, 也即package的名字.</li>
<li><strong>builder</strong>: 用于构建package的程序, 可以是一个绝对路径, 也可以是一个“builtin:”开头的内建builder.</li>
<li><strong>system</strong>: 指定可以构建该package的系统架构, 例如“x86_64-linux”或者“i686-linux”等.</li>
</ul>
<p>还有一些常用的参数:</p>
<ul>
<li><strong>args</strong>: 如果提供了这个参数, 那么会使用这个参数调用builder.</li>
<li><strong>outputHash</strong>, <strong>outputHashAlgo</strong>和<strong>outputHashMode</strong>: 如果这三个参数被提供了, 这个<code>derivation</code>被视为是一个“fixed-output derivation”, 它们分别指定了最后构建得到的package的Hash值、Hash算法以及Hash值的计算方式.</li>
</ul>
<h2 id="fixed-output-derivation-without-dependency">Fixed-Output Derivation without Dependency</h2>
<p>我们先来看一个最简单的<code>derivation</code>定义:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="ex">derivation</span> {</span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="ex">name</span> = <span class="st">&quot;busybox&quot;</span><span class="kw">;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="ex">builder</span> = <span class="st">&quot;builtin:fetchurl&quot;</span><span class="kw">;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="ex">system</span> = <span class="st">&quot;x86_64-linux&quot;</span><span class="kw">;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="ex">outputHash</span> = <span class="st">&quot;ef4c1be6c7ae57e4f654efd90ae2d2e204d6769364c46469fa9ff3761195cba1&quot;</span><span class="kw">;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="ex">outputHashAlgo</span> = <span class="st">&quot;sha256&quot;</span><span class="kw">;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="ex">outputHashMode</span> = <span class="st">&quot;recursive&quot;</span><span class="kw">;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="ex">url</span> = <span class="st">&quot;http://tarballs.nixos.org/stdenv-linux/i686/4907fc9e8d0d82b28b3c56e3a478a2882f1d700f/busybox&quot;</span><span class="kw">;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="ex">executable</span> = true<span class="kw">;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="ex">unpack</span> = false<span class="kw">;</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>}</span></code></pre></div>
<p>上述代码定义了一个名叫“busybox”的<code>derivation</code>, 其对应package构建过程所使用的builder是nix-lang内置的<code>fetchurl</code>函数, 且只能在x86_64架构的linux系统上执行. 因为我们给出了<code>ouputHash</code>等参数, 因此最后得到的package文件的Hash值已经被确定.</p>
<p>如果你正在使用NixOS <del>(那应该就不会来读这篇文档)</del> 或者已经在系统上安装了Nix <del>(如果没有请立即在shell中输入<code>curl -L https://nixos.org/nix/install | sh</code>并回车)</del> , 试着将上述代码输入到文件<code>busybox.nix</code>中然后执行:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a>$ <span class="ex">nix-build</span> busybox.nix</span></code></pre></div>
<p>那么Nix应该会提示它要开始build一些东西了, 视你的网络情况而定, 等待一段时间后应该会得到如下输出:</p>
<blockquote>
<p>/nix/store/lan2w3ab1mvpxj3ppiw2sizh8i7rpz7s-busybox</p>
</blockquote>
<p>同时当前目录下会出现一个名为<code>result</code>的符号链接指向上面的路径.</p>
<p>试着执行一下:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1"></a>$ <span class="ex">/nix/store/lan2w3ab1mvpxj3ppiw2sizh8i7rpz7s-busybox</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="ex">BusyBox</span> v1.23.2 () <span class="ex">multi-call</span> binary.</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="ex">BusyBox</span> is copyrighted by many authors between 1998-2012.</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="ex">Licensed</span> under GPLv2. See source distribution for detailed</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="ex">copyright</span> notices.</span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="ex">Usage</span>: busybox [function [arguments]...]</span>
<span id="cb3-9"><a href="#cb3-9"></a>   <span class="ex">or</span>: busybox --list</span>
<span id="cb3-10"><a href="#cb3-10"></a>   <span class="ex">or</span>: function [arguments]...</span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a>	<span class="ex">BusyBox</span> is a multi-call binary that combines many common Unix</span>
<span id="cb3-13"><a href="#cb3-13"></a>	<span class="ex">utilities</span> into a single executable.  Most people will create a</span>
<span id="cb3-14"><a href="#cb3-14"></a>	<span class="fu">link</span> to busybox for each function they wish to use and BusyBox</span>
<span id="cb3-15"><a href="#cb3-15"></a>	<span class="ex">will</span> act like whatever it was invoked as.</span>
<span id="cb3-16"><a href="#cb3-16"></a></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="ex">Currently</span> defined functions:</span>
<span id="cb3-18"><a href="#cb3-18"></a>	<span class="ex">ash</span>, mkdir, tar, unxz, xzcat</span></code></pre></div>
<p>成了, 我们的第一个package构建成功.</p>
<p>我来解释一下当我们执行<code>nix-build</code>时发生了什么:</p>
<p>首先, <code>busybox.nix</code>的内容被读取并执行, 并返回了一个<code>derivation</code>. 之后<code>nix-build</code>命令会对这个<code>derivation</code>进行求值, 即构建相应的package. 而构建package的进程会执行以下操作(按Linux上的默认设置描述):</p>
<ol type="1">
<li><p>清空环境变量, 并设置一些Nix自己使用的环境变量.</p>
<ul>
<li>这一步是为了消除环境变量可能对构建过程造成的影响.</li>
</ul></li>
<li><p>将环境变量<code>out</code>设为该package最后将存储的路径. 如之前所说这个路径以一个Hash值作为前缀, 在fixed-output derivation中, 这个Hash值通过<code>outputHash</code>参数得到.</p></li>
<li><p>将构造<code>derivation</code>所用的所有参数设置为环境变量. 例如, 在上述例子中, 除去第1步中涉及的变量, 环境变量将设置为:</p>
<pre><code>builder=&quot;builtin:fetchurl&quot;
executable=&quot;1&quot;
name=&quot;busybox&quot;
out=&quot;/nix/store/lan2w3ab1mvpxj3ppiw2sizh8i7rpz7s-busybox&quot;
outputHash=&quot;ef4c1be6c7ae57e4f654efd90ae2d2e204d6769364c46469fa9ff3761195cba1&quot;
outputHashAlgo=&quot;sha256&quot;
outputHashMode=&quot;recursive&quot;
system=&quot;x86_64-linux&quot;
unpack=&quot;&quot;
url=&quot;http://tarballs.nixos.org/stdenv-linux/i686/4907fc9e8d0d82b28b3c56e3a478a2882f1d700f/busybox&quot;</code></pre></li>
<li><p>为构建进程设置private namespace, 分别为:</p>
<ul>
<li>PID namespace, 使得构建进程只能看到自己和自己的子进程.</li>
<li>Mount namespace, 保证只有在<code>derivation</code>中指明的依赖路径(即所依赖的其他<code>derivation</code>在<code>/nix/store</code>中对应的路径), 以及<code>/proc</code>、<code>/dev</code>、<code>/etc</code>等必要的目录是可见的.</li>
<li>IPC namespace, 防止构建进程与外部进程进行通信.</li>
<li>UTS namespace, 防止构建进程获取真实的hostname.</li>
</ul></li>
<li><p>执行builder程序, 在这个例子中执行的是Nix内置的fetchurl, 这个程序会读取环境变量中<code>url</code>的值, 下载相应的文件到<code>$out</code>, 并根据<code>executable</code>和<code>unpack</code>的值决定是否进行运行权限设置和解压操作.</p></li>
<li><p>如果builder程序在<code>$out</code>路径成功创建了文件或目录, Nix会计算该路径下文件内容的Hash值并和<code>outputHash</code>参数对比. 如果<code>$out</code>没有被创建或者Hash值不相符则报错, 否则构建成功.</p></li>
</ol>
<p>这里并没有描述所有的细节, 仅仅摘录了其中比较重要的步骤. 可以看到, Nix使用了多种方法, 尽量使得<code>derivation</code>的构建进程的运行环境不受系统环境的影响, 因而在不同的机器上执行都能得到相同的结果, 也就是实现所谓的<a href="https://reproducible-builds.org/">Reproducible Build</a>, 从而使得<code>derivation</code>的求值过程符合纯函数式的定义.</p>
<h2 id="normal-derivation-with-some-dependency">Normal Derivation with Some Dependency</h2>
<p>上一节的例子中不存在对其他<code>derivation</code>的依赖, 接下来我们看一个稍微复杂一点的例子:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1"></a><span class="bu">let</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="ex">busybox</span> = derivation {</span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="ex">name</span> = <span class="st">&quot;busybox&quot;</span><span class="kw">;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="ex">builder</span> = <span class="st">&quot;builtin:fetchurl&quot;</span><span class="kw">;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="ex">system</span> = <span class="st">&quot;x86_64-linux&quot;</span><span class="kw">;</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="ex">outputHash</span> = <span class="st">&quot;ef4c1be6c7ae57e4f654efd90ae2d2e204d6769364c46469fa9ff3761195cba1&quot;</span><span class="kw">;</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="ex">outputHashAlgo</span> = <span class="st">&quot;sha256&quot;</span><span class="kw">;</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>    <span class="ex">outputHashMode</span> = <span class="st">&quot;recursive&quot;</span><span class="kw">;</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="ex">url</span> = <span class="st">&quot;http://tarballs.nixos.org/stdenv-linux/i686/4907fc9e8d0d82b28b3c56e3a478a2882f1d700f/busybox&quot;</span><span class="kw">;</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>    <span class="ex">executable</span> = true<span class="kw">;</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>    <span class="ex">unpack</span> = false<span class="kw">;</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>  };</span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="kw">in</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>  <span class="ex">derivation</span> {</span>
<span id="cb5-15"><a href="#cb5-15"></a>    <span class="ex">name</span> = <span class="st">&quot;hello-world&quot;</span><span class="kw">;</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>    <span class="ex">builder</span> = <span class="st">&quot;</span><span class="va">${busybox}</span><span class="st">&quot;</span><span class="kw">;</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>    <span class="ex">args</span> = [ <span class="st">&quot;ash&quot;</span> <span class="st">&quot;-c&quot;</span> <span class="st">&quot;echo Hello World! &gt; </span><span class="va">$out</span><span class="st">&quot;</span> ]<span class="kw">;</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>    <span class="ex">system</span> = <span class="st">&quot;x86_64-linux&quot;</span><span class="kw">;</span></span>
<span id="cb5-19"><a href="#cb5-19"></a>  }</span></code></pre></div>
<p>将以上内容写入<code>hello.nix</code>, 执行一下<code>nix-build</code>看看会发生什么:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1"></a>$ <span class="ex">nix-build</span> hello.nix</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ex">/nix/store/w62gjxd3xj487mv7dgzypgcl32na5daw-hello-world</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a>$ <span class="fu">cat</span> ./result</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="ex">Hello</span> World!</span></code></pre></div>
<p>经典的Hello World! 简单讲解一下这个例子中的代码:</p>
<p><code>let ... in</code>这段将变量<code>busybox</code>引入到作用域内, 它的值就是我们上一个小节定义的<code>derivation</code>.</p>
<p>接下来我们定义了一个名叫“hello-world”的<code>derivation</code>, 它的builder是<code>"${busybox}"</code>.</p>
<p>在nix-lang中, <code>string</code>内部出现的<code>${}</code>是<strong>antiquotation</strong>操作符, 类似于pythong的F-String中的<code>{}</code>, 也就是说<code>"prefix${&lt;expr&gt;}suffix"</code>等价于<code>"prefix" + (toString &lt;expr&gt;) + "suffix"</code>(实际上并不完全等价, nix-lang中的antiquotation有点坑, 但这里不讨论这个细节). 而对一个<code>derivation</code>执行<code>toString</code>操作返回的是它的<code>outPath</code>, 即上一小节中环境变量<code>out</code>指向的路径(这里是不会触发构建的, 因为这里相当于只是读取了<code>busybox</code>的元信息, 并没有进行读取<code>outPath</code>中的内容的操作 – 概念上可以这么理解, 具体的实现可能以后会再写一篇文档来讲 <sub>咕咕咕</sub>).</p>
<p>因此这个<code>derivation</code>的builder就是<code>"/nix/store/lan2w3ab1mvpxj3ppiw2sizh8i7rpz7s-busybox"</code>. 如你所见这里也没有提供<code>outputHash</code>, 因此这不是一个fixed-output derivation, 其构建过程会有如下不同:</p>
<ol type="1">
<li>在构建之前会首先递归地构建<code>derivation</code>的所有依赖.</li>
<li>package最后将存储的路径, 即环境变量<code>out</code>的值, 其中的Hash值部分是将构造<code>derivation</code>的所有参数以及其所依赖的所有其他<code>derivation</code>作为输入计算得到的. 如果在计算<code>derivation A</code>时使用了<code>derivation B</code>的值, 则<code>B</code>会成为<code>A</code>的依赖. 例如, 在这个例子中, 计算<code>builder</code>参数时使用了<code>busybox</code>, 因此<code>busybox</code>是这个<code>derivation</code>的依赖之一. 可以看到, Nix中的依赖在计算时就可以确定, 构建时不需要任何额外的依赖推导, 也避免了依赖推导的结果不同导致的构建结果变化.</li>
<li><code>busybox</code>的<code>outPath</code>对进程是可见的(在上一个例子中, 由于没有任何依赖, 进程在<code>/nix/store</code>下是看不到任何路径的).</li>
<li>进程会额外设置Network namespace, 防止进程访问外部网络.</li>
<li>由于这里提供了<code>args</code>参数, 执行builder程序时最终执行的命令是<code>/nix/store/...-busybox ash -c 'echo Hello World! &gt; $out'</code>.</li>
<li>Nix不会对最后的结果进行验证, 在这里Nix假设了更严格的环境限制(禁止网络访问)带来了纯函数式的求值过程.</li>
</ol>
<p>到了这里, Nix中package的构建部分就大致讲完了, 更多的细节可以参考Nix的<a href="https://nixos.org/nix/manual/#ssec-derivation">手册</a>. 基本上, Nix就是通过严格的构建环境限制尽可能地保障了构建的可重现性, 并通过Hash值而不是仅凭名称和版本号区分不同的package.</p>
<h1 id="总结">总结</h1>
<p>Nix项目本是作者Eelco Dolstra博士论文中的成果, 而其衍生的发行版NixOS属于其论文中 <em>“Future Work”</em> 这章的一部分内容. 很多人写下Future Work的时候可能并没有想着将其实现, 而Eelco不仅将其实现了, 还发展出了一个上千人的社区, 并且每年都会举办专门的讨论会议 – 虽然NixOS仍是一个小众的发行版, 但这份成果已然是我等学渣的楷模.</p>
<p>本文本来其实是想写成一篇安利向的文章的, 写完一看通篇没有什么实用的内容, 反而充斥着一些用户不需要了解的细节和作者自己的理解, 好像变成了一篇类似学习笔记的东西, 希望不要反而劝退了一些人吧ORZ.</p>
<p>后面可能考虑写一篇真正的安利、写一些使用NixOS过程中的经验分享、翻译一点<a href="https://nixos.org/nixos/nix-pills">Nix Pills</a>和<a href="https://nix.dev/">Nix.dev</a>中的内容等等 – 再说吧.</p></article></div><footer>EOF</footer></div></body></html>